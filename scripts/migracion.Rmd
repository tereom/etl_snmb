---
title: "Migracion de primera versión"
output: html_document
---


```{r, message=FALSE}
library(RSQLite)
library(plyr)
library(dplyr)
library(tidyr)
library(stringr)
```


La siguiente función lee la base de datos (dir), extrae una tabla (tabla) y 
regresa un _data frame_ con la tabla.

```{r}
leerDbTab <- function(dir, tabla){
  base_input <- src_sqlite(dir)
  tabla <- tbl(base_input, tabla)
  tabla_df <- collect(tabla)
}
```


### conglomerates -> Conglomerado_muestra y Sitio_muestra

1. Leemos las tablas de conglomerado y creamos un id utilizando la parte 
numérica del nombre de la base de datos y la columna id de la misma.

```{r}
# Leemos las rutas de las bases de datos de entrada
bases_rutas <- list.files(path = "../datos/bases_entrada", full.names = TRUE)
names(bases_rutas) <- extract_numeric(basename(bases_rutas))

# ldply asigna automáticamente el nombre del elemento de la lista como primera
# variable en el data-frame de salida
conglomerado_tabs <- ldply(bases_rutas, leerDbTab, "conglomerates")

conglomerado <- conglomerado_tabs %>%
  filter(nchar(name) <= 5) %>%  # quitamos conglomerados con nombres mal
  mutate(
    id = as.numeric(paste(.id, id, sep = "")) # creamos nueva columna id
    # Notar que al crear los id's de esta manera, eliminamos la necesidad de hacer
    # joins para obtener las llaves foráneas, ya que las conocemos de antemano.
    ) %>%
  select(-.id) # eliminamos la columna auxiliar .id
```

2. Separamos en las dos tablas Conglomerado\_muestra y Sitio\_muestra

**Falta buscar niveles conglomerate_type y property de cliente Thilo**

```{r}
# Importando el catálogo de municipio, ya que algunos registros contienen el muni-
# cipio numéricamente

cat_municipio <- unique(read.csv("../datos/adicionales/municipios.csv", 
  colClasses = "character", header = TRUE))

cat_municipio <- cat_municipio %>%
  mutate(CVE_ENT_MUN = paste(CVE_ENT, CVE_MUN, sep=""))

Conglomerado_muestra <- conglomerado %>%
  # Las operaciones entre el group_by() y el ungroup se hacen a nivel de id. (renglón)
  # El default en dplyr es por columnas
  group_by(id) %>%
  mutate(
    municipio_temp = ifelse(municipio %in% cat_municipio$CVE_ENT_MUN,
      cat_municipio$NOM_MUN[cat_municipio$CVE_ENT_MUN == municipio], municipio)
    ) %>%
  ungroup() %>%
  mutate(
    nombre = as.integer(name), 
    fecha_visita = visit_date, 
    compania = NA_character_,
    tipo = revalue(conglomerate_type, c("07) Biodiversidad" = "7 Biodiversidad")),
    estado = state,
    municipio = municipio_temp,
    tenencia = revalue(property, c("01) Ejidal" = "1 Ejidal", "02) Comunal" = "2 Comunal",
      "03) Propriedad Particular" = "3 Propiedad particular")),
    uso_suelo_tipo = NA_character_, 
    monitoreo_tipo = "SAC-MOD", 
    vegetacion_tipo = NA_character_, 
    perturbado = NA,
    comentario = comment) %>%
  # los campos se deben seleccionar en el orden en el que serán insertados
  select(id, nombre, fecha_visita, predio, compania, tipo, estado, municipio,
    tenencia, uso_suelo_tipo, monitoreo_tipo, vegetacion_tipo, perturbado,
    comentario)

# función para crear tablas de la forma: |id|sitio|valor|, para cada variable de
# latitud, longitud, etc. El nombre de la variable se obtiene del ldply.
separarSitios <- function(base_df, variable){
  base_var <- base_df  %>%
    select(id, contains(variable)) %>%
    gather(sitio, value, -id) %>%
    mutate(sitio = str_extract(sitio, "[[:alnum:]]+"))
  base_var
}

# variables que extraemos para la tabla Sitio_muestra
variables <- c("lat", "lon", "altitude", "ellipsoid", "gps_error")
names(variables) <- variables

sitio <- ldply(variables, separarSitios, base_df = conglomerado) %>%
  spread(.id, value)

Sitio_muestra <- sitio %>%
  mutate(
    conglomerado_muestra_id = as.integer(id), 
    id = 1:length(id),
    sitio_numero = revalue(sitio, c("central" = "Centro", "transect2" = "Sitio 2",
      "transect3" = "Sitio 3", "transect4" = "Sitio 4")),
    # Web2py definió los campos boolean como char(1): T o F en la base de datos
    existe = "T",
    lat = as.numeric(lat),
    lon = as.numeric(lon),
    
    # Nota: no se está revisando por errores al introducir las coordenadas (por
    # ejemplo, si su GPS estaba en grados y dividieron la expansión decimal para
    # llenar los campos correspondientes a minutos y segundos)
    lat_grado = as.integer(lat), 
    lat_min = floor(60 * abs(lat - lat_grado)),
    lat_seg = (3600 * abs(lat - lat_grado - sign(lat) * lat_min / 60)),
    lon_grado = as.integer(lon), 
    lon_min = floor(60 * abs(lon - lon_grado)),
    lon_seg = (3600 * abs(lon - lon_grado - sign(lon) * lon_min / 60)),
    
    elipsoide = ellipsoid,
    gps_error = as.numeric(gps_error),
    altitud = as.numeric(altitude),
    hay_evidencia = NA
    ) %>%
  select(id, conglomerado_muestra_id, sitio_numero, existe, lat_grado, lat_min,
    lat_seg, lon_grado, lon_min, lon_seg, altitud, gps_error, elipsoide,
    hay_evidencia)  
```

#### invaders, file_invasores -> Transecto_especie_invasora, Especie_invasora, Archivo_Especie_invasora

Filtramos para únicamente tener registros asociados a los conglomerados en la 
tabla Conglomerado_muestra.

```{r}
invasora_tabs <- ldply(bases_rutas, leerDbTab, "invaders")
archivos_invasora_tabs <- ldply(bases_rutas, leerDbTab, "files_invasores")

# creamos nuevos ids pegando id base de datos con ids de tabla
invasora <- invasora_tabs %>%
  mutate(
    id = as.numeric(paste(.id, id, sep = "")),
    conglomerate_id = as.numeric(paste(.id, conglomerate_id, sep = ""))
  ) %>%
  filter(conglomerate_id %in% Conglomerado_muestra$id & number_individuals > 0) %>%
  # Se filtran los registros sin individuos, puesto que:
  # 1. A veces si un transecto no tenía individuos, no lo introducían, pero a ve
  # ces declaraban un invader "fantasma" y ponían en comentarios que no se habían
  # encontrado individuos. Hay que estandarizar.
  # 2. Los invaders "fantasma" pueden llenar de basura la tabla de especies inva-
  # soras.
  select(-.id) 

archivos_invasora <- archivos_invasora_tabs %>%
  mutate(
    id = as.numeric(paste(.id, id, sep = "")),
    invaders_id = as.numeric(paste(.id, invaders_id, sep = ""))
  ) %>%
  # Como se filtró para obtener "invasora", debemos filtrar esta tabla también
  # para mantener consistencia.
  filter(invaders_id %in% invasora$id) %>%
  select(-.id) 
```

Tablas a exportar
**en archivo quitamos ruta?**
**como trabajar las horas?**

```{r}
Archivo_especie_invasora <- archivos_invasora %>%
  mutate(
    especie_invasora_id = invaders_id,
    archivo_nombre_original = str_extract(old_filename, regex("[[:word:]]+\\.[[:word:]]+")),
    # Word matchea letras, números y guiones bajos.
    archivo = str_extract(filename, regex("[[:word:]]+\\.[[:word:]]+"))
    ) %>%
  select(id, especie_invasora_id, archivo_nombre_original, archivo)

# Asignamos como id del transecto el id de la primera especie invasora
transecto_especies_invasoras <- invasora %>%
  separate(transect, c("nombre", "transecto_numero"), sep = "/") %>%
  group_by(conglomerate_id, transecto_numero) %>%
  mutate(
    transecto_especies_invasoras_id = first(id)
  ) %>%
  ungroup()

# Obtenemos la fecha de la tabla Conglomerado_muestra
conglomerado_fechas <- select(Conglomerado_muestra, id, fecha_visita)

Transecto_especies_invasoras_muestra <- transecto_especies_invasoras %>%
  # Unimos por conglomerate_id para obtener la fecha
  left_join(conglomerado_fechas, by = c("conglomerate_id" = "id")) %>%
  group_by(conglomerate_id, transecto_numero) %>%
  # En el summarise es donde se cambia el tamaño de la tabla, agrupando valores
  summarise_each(funs(first)) %>%
  ungroup() %>%
  mutate(
    transecto_numero = revalue(transecto_numero, 
      c("T2" = "Transecto 2", "T3" = "Transecto 3", "T4" = "Transecto 4")),
    fecha = fecha_visita,
    hora_inicio = str_extract(start_time, regex("[0-9]{2}:[0-9]{2}:[0-9]{2}")), 
    hora_termino = str_extract(stop_time, regex("[0-9]{2}:[0-9]{2}:[0-9]{2}")), 
    tecnico = technician,
    comentario = comment
  ) %>%
  select(id = transecto_especies_invasoras_id, 
    conglomerado_muestra_id = conglomerate_id, fecha,
    transecto_numero, tecnico, hora_inicio, hora_termino, comentario)

# esto se puede simplificar considerando que no hay especies con cero individuos
# debido a que filtramos estos registros
# transecto_especies_invasoras$numero_individuos = cut(
#   transecto_especies_invasoras$number_individuals, 
#   breaks = c(-Inf, 0, 5, 10, 90, Inf))
# levels(transecto_especies_invasoras$numero_individuos) <- list(
#   "No aplica" = c("(-Inf,0]", "(90, Inf]"), 
#   "1 a 5" = "(0,5]", 
#   "6 a 10" = "(5,10]", 
#   "más de 10" = "(10,90]")

Especie_invasora <- transecto_especies_invasoras %>%
  mutate(
    nombre_en_lista = ifelse(is.na(conabio_list_name),"F","T"),
    nombre_comun = ifelse(name_type == "common name", species_name, NA), 
    nombre_cientifico = ifelse(name_type != "common name", species_name, NA),
    numero_individuos = as.character(cut(number_individuals, 
      breaks = c(0, 5, 10, 90, 99), 
      labels = c("1 a 5", "6 a 10", "más de 10", "No aplica")))
  ) %>%
  select(id, transecto_especies_invasoras_id, nombre_en_lista, nombre_comun, 
    nombre_cientifico, numero_individuos)  
```

#### tracks_excrements, file_tracks_excrements -> Transecto_huellas_excretas, Huella_excreta, Archivo_huella_excreta

```{r}
huella_tabs <- ldply(bases_rutas, leerDbTab, "tracks_excrements")
archivos_huella_tabs <- ldply(bases_rutas, leerDbTab, "files_tracks_excrements")

# obtenemos la hora inicio y hora término de la tabla invaders
invasora_horas <- select(invasora_tabs, transect, start_time, stop_time) %>%
  group_by(transect) %>%
  summarise_each(funs(first)) %>%
  ungroup()

# creamos nuevos ids pegando id base de datos con ids de tabla
huella_excreta <- huella_tabs %>%
  left_join(invasora_horas, by = "transect") %>%
  mutate(
    id = as.numeric(paste(.id, id, sep = "")),
    conglomerate_id = as.numeric(paste(.id, conglomerate_id, sep = ""))
  ) %>%
  filter(conglomerate_id %in% Conglomerado_muestra$id) %>%
  select(-.id) 

archivos_huella_excreta <- archivos_huella_tabs %>%
  mutate(
    id = as.numeric(paste(.id, id, sep = "")),
    tracks_excrements_id = as.numeric(paste(.id, tracks_exrements_id, sep = ""))
  ) %>%
  filter(tracks_excrements_id %in% huella_excreta$id) %>%
  select(-.id) 
```

Tablas a exportar
**en archivo quitamos ruta?**
**como trabajar las horas?**
**species_name en nombre comun o en nombre cientifico?**

```{r}
Archivo_huella_excreta <- archivos_huella_excreta %>%
  mutate(
    huella_excreta_id = tracks_excrements_id,
    archivo_nombre_original = str_extract(old_filename, regex("[[:word:]]+\\.[[:word:]]+")),
    # Word matchea letras, números y guiones bajos.
    archivo = str_extract(filename, regex("[[:word:]]+\\.[[:word:]]+"))
    ) %>%
  select(id, huella_excreta_id, archivo_nombre_original, archivo)

# Asignamos como id del transecto el id de la primera huella/excreta
transecto_huellas_excretas <- huella_excreta %>%  
  separate(transect, c("nombre", "transecto_numero"), sep = "/") %>%
  group_by(conglomerate_id, transecto_numero) %>%
  mutate(
    transecto_huellas_excretas_id = first(id)
  ) %>%
  ungroup()


Transecto_huellas_excretas_muestra <- transecto_huellas_excretas %>%
  group_by(conglomerate_id, transecto_numero) %>%
  summarise_each(funs(first)) %>%
  ungroup() %>%
  mutate(
    transecto_numero = revalue(transecto_numero, 
      c("T2" = "Transecto 2", "T3" = "Transecto 3", "T4" = "Transecto 4")),
    tecnico = technician,
    fecha = NA,
    hora_inicio = start_time, 
    hora_termino = stop_time, 
    comentario = comment
  ) %>%
  select(id = transecto_huellas_excretas_id, 
    conglomerado_muestra_id = conglomerate_id, fecha,
    transecto_numero, tecnico, hora_inicio, hora_termino, comentario)

Huella_excreta <- transecto_huellas_excretas %>%
  mutate(
    es_huella = observation_type == "tracks",
    largo = length,
    ancho = width,
    nombre_comun = species_name, 
    nombre_cientifico = species_name
  ) %>%
  select(id, transecto_huellas_excretas_id, es_huella, nombre_comun, 
    nombre_cientifico, largo, ancho)  

```

```{r´}
base_output <- dbConnect(RSQLite::SQLite(), "../datos/base_salida/base_output.db")
dbWriteTable(base_output, "Conglomerado_muestra", as.data.frame(Conglomerado_muestra),
      overwrite = FALSE, append = TRUE)
#dbCommit(base_output)
dbDisconnect(base_output)
dbWriteTable(base_output, "Sitio_muestra", as.data.frame(Sitio_muestra),
      overwrite = FALSE, append = TRUE)
```
